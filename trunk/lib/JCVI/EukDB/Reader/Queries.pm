# File: Queries.pm
# Author: kgalinsk
# Created: Dec 31, 2009
#
# $Author$
# $Date$
# $Revision$
# $HeadURL$
#
# Copyright 2009, J. Craig Venter Institute
#
# JCVI::EukDB::Reader::Queries - generate query methods

package JCVI::EukDB::Reader::Queries;

use strict;
use warnings;

use Params::Validate;

use Sybase::TempTable;

=head1 NAME

JCVI::EukDB::Reader::Queries - generate query methods

=head1 SYNOPSIS

    use JCVI::Queries;
    JCVI::Queries->make_queries( [ $input, $output, $linkage, $addl_clauses ] );
    JCVI::Queries->make_queries( \@query1_options, \@query2_options, ... );

    use JCVI::Queries \@query1_options, \@query2_options, ...;

=head1 DESCRIPTION

This object will make a set of query methods in your class. It has one publicly
visible method, make_queries, that gets called either through import of
directly. This method will take a set of options presented as an array for a
particular query, and autogenerates the query methods for you.

=cut

=head1 CLASS FUNCTIONS

=cut

=head1 make_queries

Takes the input type (i.e. feat_name), output type (i.e. parent), linkage or 
conversion table (i.e. feat_link or asm_feature), and optional additional 
clauses to customize the operation of the query.  The additional clauses 
should be a hashref structured in the following way:

    #tables stores any additional tables for the query beyond the linkage 
    #  table, and clauses stores additional parts of the WHERE clause beyond 
    #  simply joining on the linkage table
    $addl_clauses = { 
        tables  => [<array_of_table_hashes>]
        clauses => [<array_of_clause_hashes>],
    }
    
    #a table hash stores the name of the additional table, as well as a 
    #  clause hash to tell how to join the new table in the query
    $table_hash = {
        table   => $table_name,
        clauses => [<array_of_clause_hashes>]
    }
    
    #the clause hash describes how to assemble the additional WHERE clause. 
    #  if both r_col and r_val are defined, it is assumed that a test is 
    #  desired for both the column and the value, and a clause will be 
    #  assembled for both.
    $clause_hash = {
        l_table => $l_table_name,
        l_col   => $l_column_name,
        r_table => $r_table_name,
        r_col   => $r_column_name,
        r_val   => $r_value,
        comp    => [= != LIKE <= >=],  #default: =
        link    => [AND OR]            #default: AND
    }

Methods for data conversion will then be autogenerated to use the queries 
defined by the parameters passed to make_queries.

=cut

sub make_queries {
    my $class  = shift;
    my $caller = caller();

    my @queries =
      validate_pos( @_, ( { type => Params::Validate::ARRAYREF } ) x @_ );

    foreach my $query (@queries) { $class->_make_query( $caller, @$query ) }
}

*import = \&make_queries;

no strict 'refs';

sub _make_query {
    my $class  = shift;
    my $caller = shift;

    my ( $input, $output, $linkage, $addl_clauses ) = validate_pos(
        @_,
        { type => Params::Validate::SCALAR | Params::Validate::HASHREF },
        { type => Params::Validate::SCALAR | Params::Validate::HASHREF },
        { type => Params::Validate::SCALAR | Params::Validate::HASHREF },
        { type => Params::Validate::HASHREF, optional => 1 }
    );

    $input   = { name  => $input }   unless ( ref($input) );
    $output  = { name  => $output }  unless ( ref($output) );
    $linkage = { table => $linkage } unless ( ref($linkage) );

    my $input_name   = $input->{name};
    my $input_as     = $input->{as} || $input->{name};
    my $input_plural = $input->{plural} || "$input->{name}s";

    my $output_name   = $output->{name};
    my $output_as     = $output->{as} || $output->{name};
    my $output_plural = $output->{plural} || "$output->{name}s";

    my $linkage_table = $linkage->{table};
    my $linkage_column = $linkage->{column} || $input->{name};

    my $addl_statement_pieces =
      _handle_additional_clauses_and_tables( $addl_clauses, $linkage_table );
    my ( $addl_from, $addl_where ) = @$addl_statement_pieces;

    my $tt2tt_name =
      "${input_plural}_temp_table_to_${output_plural}_temp_table";
    my $tt2tt_short = "${input_plural}_tt2${output_plural}_tt";

    my $tt2tt       = sub {
        my $self = shift;
        my ($temp1) = validate_pos( @_, { can => ['name'] } );

        my $dbh = $self->dbh;

        my $temp2 = Sybase::TempTable->reserve($dbh);

        my $temp1_name = $temp1->name;
        my $temp2_name = $temp2->name;

        my $sth = $dbh->prepare(
            qq{
                SELECT  t.$input_name AS $input_as,
                        l.$output_name AS $output_as
                INTO    $temp2_name
                FROM    $temp1_name t, $linkage_table l}
              . $addl_from
              . qq{ WHERE   t.$input_name = l.$linkage_column }
              . $addl_where
        );
        $sth->execute();
        $sth->finish;

        return $temp2;
    };

    *{"${caller}::$tt2tt_name"}  = \&$tt2tt;
    *{"${caller}::$tt2tt_short"} = \&$tt2tt;

    my $arrayref2tt_name =
      "${input_plural}_arrayref_to_${output_plural}_temp_table";
    my $arrayref2tt_short = "${input_plural}_arrayref2${output_plural}_tt";

    my $arrayref2tt = sub {
        my $self = shift;
        my ($arrayref) =
          validate_pos( @_, { type => Params::Validate::ARRAYREF } );

        my $dbh = $self->dbh;

        my $temp      = Sybase::TempTable->reserve($dbh);
        my $temp_name = $temp->name;

        my $sth = $dbh->prepare(
            qq{
                SELECT  $linkage_column AS $input_as,
                        $output_name AS $output_as
                INTO    $temp_name
                FROM    $linkage_table} . $addl_from . qq{
                WHERE   $linkage_column IN (}
              . join( ',', ('?') x @$arrayref ) . qq{ )
            } . $addl_where
        );
        $sth->execute(@$arrayref);
        $sth->finish;

        return $temp;
    };

    *{"${caller}::$arrayref2tt_name"}  = \&$arrayref2tt;
    *{"${caller}::$arrayref2tt_short"} = \&$arrayref2tt;
}

##############################################################################
#takes:    the additional clauses hash and the linkage_table passed as
#            parameters to make_queries.
#does:     uses addl_clauses to properly assemble the additions to the FROM
#            and WHERE clauses in the SQL query being auto-generated.
#returns:  an arrayref containing the FROM additions at index 0 and the
#            WHERE additions at index 1, both as strings.
##############################################################################
sub _handle_additional_clauses_and_tables {
    my ( $addl_clauses, $linkage_table ) = @_;

    my $addl_from  = "";
    my $addl_where = "";
    my %tables_to_aliases;
    $tables_to_aliases{$linkage_table} = 'l';

    for ( my $i = 0 ; $i < @{ $addl_clauses->{tables} } ; $i++ ) {
        my $table_name = ${ $addl_clauses->{tables} }[$i]->{table};
        $table_name =~ s/\s//g;
        $addl_from .= ", " . $table_name . "as $i";
        $tables_to_aliases{$table_name} = $i;
    }

    $addl_where .=
      _assemble_clauses( $addl_clauses->{clauses}, \%tables_to_aliases );

    foreach my $table_hash ( @{ $addl_clauses->{tables} } ) {
        $addl_where .= _assemble_clauses( $table_hash->{clauses} );
    }

    return [ $addl_from, $addl_where ];
}

##############################################################################
#A helper method for _handle_additional_clauses_and_tables.
#takes:    an arrayref of clause hashes and a hashref to convert table names
#            to aliases used in the query.
#does:     assembles the additions to the WHERE clause
#returns:  the assembled parts all as a single string
##############################################################################
sub _assemble_clauses {
    my ( $clause_arrayref, $tables_to_aliases ) = @_;

    my $assembled_clauses = "";

    foreach my $clause ( @{$clause_arrayref} ) {
        #guard against any unwanted SQL statements by eliminating spaces
        map $clause->{$_} =~ s/\s//g, keys %$clause;

        #check the validity of the comparators
        my ( $comp, $link );
        unless ( $comp = $clause->{comp} ) {
            $comp = '=';
        }
        else {
            logcroak("Unknown comparator for additional clause.")
              unless ( $comp =~ m/^=$|^!=$|^<=$|^>=$|^LIKE$/ );
        }

        #check the validity of the linkers
        unless ( $link = $clause->{link} ) {
            $link = 'AND';
        }
        else {
            logcroak("Unknown linking keyword for additional clause.")
              unless ( $link =~ m/^AND$|^OR$/ );
        }

        #check to make sure valid table names are used and get their aliases
        my $l_alias = $tables_to_aliases->{ $clause->{l_table} };
        my $r_alias = $tables_to_aliases->{ $clause->{r_table} };

        my $addl_clause =
          "\n$link $l_alias." . $clause->{l_col} . " $comp $r_alias.";
        if ( $clause->{r_col} && $clause->{r_val} ) {
            $addl_clause .=
              $addl_clause . $clause->{r_col} . $addl_clause . $clause->{r_val};
        }
        else {
            $addl_clause .=
              ( $clause->{r_col} ) ? $clause->{r_col} : $clause->{r_val};
        }
        $assembled_clauses .= $addl_clause;
    }

    return $assembled_clauses;
}

1;
